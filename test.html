<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>NEON DASH 0.1 - MOBILE OPTIMIZED</title>
<style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
    body { margin: 0; overflow: hidden; background: #020202; font-family: 'Orbitron', sans-serif; user-select: none; touch-action: none; }
    canvas { display: block; }
    
    /* Neon Mobile Buttons - Initially Hidden */
    .mobile-controls {
        position: absolute;
        bottom: 40px;
        width: 100%;
        display: none; /* Hidden by default */
        justify-content: space-between;
        padding: 0 40px;
        box-sizing: border-box;
        z-index: 10;
    }
    .btn {
        width: 80px;
        height: 80px;
        border: 3px solid #00ffff;
        border-radius: 50%; /* Circular for better thumb feel */
        display: flex;
        align-items: center;
        justify-content: center;
        color: #00ffff;
        font-size: 35px;
        background: rgba(0, 255, 255, 0.1);
        box-shadow: 0 0 15px #00ffff, inset 0 0 10px #00ffff;
        pointer-events: auto;
        transition: transform 0.05s;
    }
    .btn:active {
        transform: scale(0.85);
        background: rgba(0, 255, 255, 0.4);
    }
</style>
</head>
<body>

<div class="mobile-controls" id="ui-controls">
    <div class="btn" id="left-btn">◀</div>
    <div class="btn" id="right-btn">▶</div>
</div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const uiControls = document.getElementById("ui-controls");
let lanePositions = [];

const COLORS = {
    player: "#00ffff", 
    obstacle: "#ff0055", 
    boost: "#ffcc00",
    gold: "#FFD700",
    track: "rgba(0, 255, 255, 0.08)",
    text: "#ffffff",
    overlay: "rgba(0, 0, 0, 0.85)"
};

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const center = canvas.width / 2;
    const spacing = Math.min(canvas.width / 3.2, 120);
    lanePositions = [center - spacing, center, center + spacing];
}
window.addEventListener("resize", resize);
resize();

/* ============ GAME STATE ============ */
let gameState = {
    started: false, paused: false, gameOver: false,
    showGameOverUI: false,
    score: 0, highScore: parseInt(localStorage.getItem('neonDashHigh')) || 0,
    speed: 8, baseSpeed: 8,
    lastMilestone: 0, 
    boostActive: false, boostTimer: 0, boostDuration: 500
};

const player = {
    lane: 1, x: 0, targetX: 0, y: 0, w: 35, h: 35, 
    vy: 0, groundY: 0, isJumping: false
};

function initPlayer() {
    player.groundY = canvas.height - 180; 
    player.y = player.groundY;
    player.lane = 1;
    player.targetX = lanePositions[1];
    player.x = lanePositions[1];
}
initPlayer();

let obstacles = [];
let boosts = [];
let trail = [];

function resetGame() {
    gameState.started = true; gameState.paused = false; gameState.gameOver = false;
    gameState.showGameOverUI = false;
    gameState.score = 0; gameState.speed = 8; gameState.baseSpeed = 8;
    gameState.lastMilestone = 0; gameState.boostActive = false;
    obstacles = []; boosts = []; trail = [];
    uiControls.style.display = "flex"; // Show buttons when game starts
    initPlayer();
}

function moveLeft() { if (player.lane > 0) { player.lane--; player.targetX = lanePositions[player.lane]; } }
function moveRight() { if (player.lane < 2) { player.lane++; player.targetX = lanePositions[player.lane]; } }
function jump() { if (!player.isJumping) { player.vy = -18; player.isJumping = true; } }

/* ============ INPUT HANDLING ============ */

// Keyboard
document.addEventListener("keydown", e => {
    if (e.code === "Space") {
        if (!gameState.started || gameState.showGameOverUI) resetGame();
        else gameState.paused = !gameState.paused;
    }
    if (gameState.paused || gameState.gameOver || !gameState.started) return;
    if (e.key === "ArrowLeft" || e.code === "KeyA") moveLeft();
    if (e.key === "ArrowRight" || e.code === "KeyD") moveRight();
    if (e.key === "ArrowUp" || e.code === "KeyW") jump();
});

// Mobile Button Listeners
document.getElementById("left-btn").addEventListener("touchstart", (e) => {
    e.preventDefault();
    moveLeft();
}, {passive: false});

document.getElementById("right-btn").addEventListener("touchstart", (e) => {
    e.preventDefault();
    moveRight();
}, {passive: false});

// Canvas Tap for Jump/Start
canvas.addEventListener("touchstart", e => {
    e.preventDefault();
    if (!gameState.started || gameState.showGameOverUI) {
        resetGame();
    } else if (gameState.paused) {
        gameState.paused = false;
    } else {
        jump();
    }
}, {passive: false});

/* ============ DRAWING HELPERS ============ */
function drawNeonRect(x, y, w, h, color, isPlayer = false) {
    ctx.save();
    ctx.translate(x, y);
    let activeColor = color;
    if (isPlayer && gameState.boostActive) {
        activeColor = (Math.floor(Date.now()/100)%2 === 0) ? COLORS.player : COLORS.boost;
    }
    ctx.shadowBlur = 15; 
    ctx.shadowColor = activeColor;
    ctx.fillStyle = activeColor;
    ctx.fillRect(-w/2, -h, w, h);
    ctx.restore();
}

function drawLightning(x, y) {
    ctx.save();
    ctx.translate(x, y);
    ctx.shadowBlur = 15;
    ctx.shadowColor = COLORS.boost;
    ctx.fillStyle = COLORS.boost;
    ctx.beginPath();
    ctx.moveTo(5, -15); ctx.lineTo(-8, 0); ctx.lineTo(-2, 0);
    ctx.lineTo(-8, 15); ctx.lineTo(8, -4); ctx.lineTo(2, -4);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
}

/* ============ MAIN LOOP ============ */
function update() {
    if (!gameState.started || gameState.paused || gameState.gameOver) {
        if(gameState.gameOver) uiControls.style.display = "none";
        return;
    }

    // Speed progression
    gameState.speed += (gameState.baseSpeed - gameState.speed) * 0.05;
    if (gameState.score > (gameState.lastMilestone + 1) * 500) {
        gameState.lastMilestone++;
        gameState.baseSpeed += 0.8;
    }

    // Player Physics
    player.x += (player.targetX - player.x) * 0.2;
    player.vy += 0.9; // Gravity
    player.y += player.vy;
    if (player.y > player.groundY) { player.y = player.groundY; player.vy = 0; player.isJumping = false; }

    // Boost Logic
    if (gameState.boostActive) {
        gameState.boostTimer--;
        if (gameState.boostTimer <= 0) gameState.boostActive = false;
    }

    // Spawn Logic
    if (Math.random() < 0.02 + (gameState.lastMilestone * 0.005)) {
        if (obstacles.length < 5) {
            obstacles.push({ x: lanePositions[Math.floor(Math.random()*3)], y: -50 });
        }
    }
    if (Math.random() < 0.003 && !gameState.boostActive) {
        boosts.push({ x: lanePositions[Math.floor(Math.random()*3)], y: -50 });
    }

    // Move & Collide Obstacles
    for (let i = obstacles.length - 1; i >= 0; i--) {
        obstacles[i].y += gameState.speed;
        let o = obstacles[i];
        
        // Better Collision Box
        if (Math.abs(player.x - o.x) < 30 && Math.abs(player.y - 20 - o.y) < 30) {
            if (gameState.boostActive) {
                obstacles.splice(i, 1);
                gameState.score += 50;
            } else {
                gameState.gameOver = true;
                if (gameState.score > gameState.highScore) {
                    gameState.highScore = gameState.score;
                    localStorage.setItem('neonDashHigh', gameState.highScore);
                }
            }
        }
        if (o.y > canvas.height + 50) {
            obstacles.splice(i, 1);
            gameState.score += 10;
        }
    }

    // Boost Pickup
    for (let i = boosts.length - 1; i >= 0; i--) {
        boosts[i].y += gameState.speed;
        if (Math.abs(player.x - boosts[i].x) < 35 && Math.abs(player.y - boosts[i].y) < 35) {
            gameState.boostActive = true;
            gameState.boostTimer = gameState.boostDuration;
            boosts.splice(i, 1);
        }
        if (boosts[i].y > canvas.height + 50) boosts.splice(i, 1);
    }
}

function loop() {
    ctx.fillStyle = "#020202";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Grid Lines
    ctx.strokeStyle = COLORS.track;
    lanePositions.forEach(x => {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke();
    });

    if (!gameState.gameOver) drawNeonRect(player.x, player.y, player.w, player.h, COLORS.player, true);
    obstacles.forEach(o => drawNeonRect(o.x, o.y, 40, 40, COLORS.obstacle));
    boosts.forEach(b => drawLightning(b.x, b.y));

    // UI
    if (gameState.started && !gameState.gameOver) {
        ctx.fillStyle = "#fff"; ctx.font = "14px Orbitron"; ctx.textAlign = "left";
        ctx.fillText("SCORE: " + gameState.score, 20, 40);
        ctx.textAlign = "right";
        ctx.fillText("HI: " + gameState.highScore, canvas.width - 20, 40);
    }

    if (!gameState.started) {
        ctx.fillStyle = COLORS.overlay; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.textAlign = "center"; ctx.fillStyle = COLORS.player; ctx.font = "30px Orbitron";
        ctx.fillText("NEON DASH", canvas.width/2, canvas.height/2 - 20);
        ctx.fillStyle = "#fff"; ctx.font = "12px Orbitron";
        ctx.fillText("TAP TO START", canvas.width/2, canvas.height/2 + 20);
    } else if (gameState.gameOver) {
        ctx.fillStyle = COLORS.overlay; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.textAlign = "center"; ctx.fillStyle = COLORS.obstacle; ctx.font = "35px Orbitron";
        ctx.fillText("CRASHED", canvas.width/2, canvas.height/2 - 40);
        ctx.fillStyle = "#fff"; ctx.font = "18px Orbitron";
        ctx.fillText("SCORE: " + gameState.score, canvas.width/2, canvas.height/2 + 10);
        ctx.font = "12px Orbitron";
        ctx.fillText("TAP TO REFRESH", canvas.width/2, canvas.height/2 + 50);
    }

    update();
    requestAnimationFrame(loop);
}
loop();
</script>
</body>
</html>
